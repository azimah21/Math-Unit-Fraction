// Unit Fraction Addition Game (clean rebuild)
// Requires these IDs in index.html:
// choicesGrid, targetFraction, targetBar, selBar1, selBar2,
// feedback, questionProgress, score, checkBtn, nextBtn, resetBtn,
// summary (optional), finalScore (optional), playAgainBtn (optional).

(() => {
  // -------- DOM --------
  const $ = id => document.getElementById(id);
  const choicesGrid = $('choicesGrid');
  const targetFractionEl = $('targetFraction');
  const targetBar = $('targetBar');
  const selBar1 = $('selBar1');
  const selBar2 = $('selBar2');
  const feedback = $('feedback');
  const questionProgressEl = $('questionProgress');
  const scoreEl = $('score');
  const checkBtn = $('checkBtn');
  const nextBtn = $('nextBtn');
  const resetBtn = $('resetBtn');
  const summary = $('summary');
  const finalScoreEl = $('finalScore');
  const playAgainBtn = $('playAgainBtn');

  // -------- Config --------
  const MIN_DEN = 2;
  const MAX_DEN = 20;
  const CHOICES_COUNT = 8;
  const MIN_TARGET = 4; // keep targets that have reasonable pairs in [2..20]
  const MAX_TARGET = 18;

  // -------- State --------
  const state = {
    q: 1,
    total: 10,
    score: 0,
    attempts: 0,
    wrong: 0,
    locked: false,
    target: 0,
    solutionPair: [0, 0],
    choices: [],
    selection: [], // at most 2, always distinct
  };

  // -------- Utils --------
  const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
  const shuffle = arr => {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  };
  const lcm = (a, b) => (a * b) / gcd(a, b);
  const gcd = (a, b) => (b ? gcd(b, a % b) : a);

  function setFeedback(html, cls = '') {
    feedback.innerHTML = cls ? `<span class="${cls}">${html}</span>` : html;
  }

  function renderFractionBar(container, denom) {
    container.innerHTML = '';
    if (!denom) return;
    for (let i = 0; i < denom; i++) {
      const seg = document.createElement('div');
      seg.className = 'segment' + (i === 0 ? ' shaded' : '');
      container.appendChild(seg);
    }
    const label = document.createElement('div');
    label.className = 'fraction-label';
    label.textContent = `1/${denom}`;
    container.appendChild(label);
  }

  // All valid (a,b) with a!=b and a,b within [MIN_DEN..MAX_DEN] for target n
  function allValidPairsFor(n) {
    const pairs = [];
    for (let a = n + 1; a <= MAX_DEN; a++) {
      const denom = a - n;
      const num = n * a;
      if (denom <= 0) continue;
      if (num % denom !== 0) continue;
      const b = num / denom;
      if (!Number.isInteger(b)) continue;
      if (b < MIN_DEN || b > MAX_DEN) continue;
      if (a === b) continue; // must be different
      pairs.push([a, b]);
    }
    return pairs;
  }

  // Build a round: target with at least one valid pair; 8 unique ‚Äúsensible‚Äù choices
  function makeRound() {
    for (let tries = 0; tries < 200; tries++) {
      const n = rand(MIN_TARGET, MAX_TARGET);
      const pairs = allValidPairsFor(n);
      if (pairs.length === 0) continue;

      const pair = pairs[rand(0, pairs.length - 1)];
      const universe = [...new Set(pairs.flat())]; // all denominators that ever appear for this n

      // Start choices with the solution pair, then fill from universe, then pad if needed.
      const choiceSet = new Set(pair);
      shuffle(universe).forEach(d => {
        if (choiceSet.size < CHOICES_COUNT) choiceSet.add(d);
      });
      while (choiceSet.size < CHOICES_COUNT) {
        choiceSet.add(rand(MIN_DEN, MAX_DEN));
      }
      const choices = shuffle([...choiceSet]).slice(0, CHOICES_COUNT);
      return { n, pair, choices };
    }
    // Extremely unlikely fallback
    const n = 8;
    const pair = [5, 20];
    const choices = shuffle([5, 20, 16, 4, 10, 12, 18, 6]);
    return { n, pair, choices };
  }

  function updateHUD() {
    if (questionProgressEl) questionProgressEl.textContent = `Question ${state.q}/${state.total}`;
    if (scoreEl) scoreEl.textContent = `Score: ${state.score}`;
  }

  function resetSelectionUI() {
    state.selection = [];
    selBar1.innerHTML = '';
    selBar2.innerHTML = '';
    checkBtn.disabled = true;
    [...choicesGrid.querySelectorAll('.choice')].forEach(b => b.classList.remove('selected'));
  }

  function startRound() {
    state.locked = false;
    state.attempts = 0;
    state.wrong = 0;
    nextBtn.disabled = true;

    const { n, pair, choices } = makeRound();
    state.target = n;
    state.solutionPair = pair;
    state.choices = choices;

    targetFractionEl.textContent = `1/${n}`;
    renderFractionBar(targetBar, n);
    resetSelectionUI();
    setFeedback('Pick two denominators, then press Check.');

    // Render choice buttons
    choicesGrid.innerHTML = '';
    choices.forEach(den => {
      const btn = document.createElement('button');
      btn.className = 'choice';
      btn.textContent = den;
      btn.addEventListener('click', () => onChoice(btn, den));
      choicesGrid.appendChild(btn);
    });

    updateHUD();
  }

  function onChoice(btn, denom) {
    if (state.locked) return;
    const i = state.selection.indexOf(denom);
    if (i >= 0) {
      state.selection.splice(i, 1);
      btn.classList.remove('selected');
    } else {
      if (state.selection.length === 2) return;
      // prevent picking the same number twice by construction (array holds uniques)
      state.selection.push(denom);
      btn.classList.add('selected');
    }
    // update bars
    renderFractionBar(selBar1, state.selection[0] || 0);
    renderFractionBar(selBar2, state.selection[1] || 0);
    checkBtn.disabled = state.selection.length !== 2;
  }

  // Strict unit-fraction equality test with integers; also enforce a‚â†b
  function isCorrectPair(a, b, n) {
    if (a === b) return false;
    const ab = a * b;
    const sumNum = a + b; // (a+b)/ab
    return ab % sumNum === 0 && ab / sumNum === n;
  }

  function explain(a, b, n) {
    const ab = a * b, sumNum = a + b;
    const nCalc = ab % sumNum === 0 ? ab / sumNum : null;
    const approx = (1 / a + 1 / b).toFixed(3);
    if (nCalc === n) {
      return `1/${a} + 1/${b} = (${a}+${b})/(${a}√ó${b}) = ${sumNum}/${ab} = 1/${n}. üéØ`;
    }
    return `1/${a} + 1/${b} = ${sumNum}/${ab}${nCalc ? ` = 1/${nCalc}` : ''} (‚âà ${approx}). Target: 1/${n}.`;
  }

  function checkAnswer() {
    if (state.selection.length !== 2 || state.locked) return;
    const [a, b] = state.selection;
    state.attempts++;

    const ok = isCorrectPair(a, b, state.target);
    if (ok) {
      state.score++;
      setFeedback(explain(a, b, state.target) + ' <b>Awesome! Right on target!</b>', 'ok');
      state.locked = true;
      nextBtn.disabled = false; // early advance if correct within 5 tries
    } else {
      state.wrong++;
      setFeedback(explain(a, b, state.target) + ' <b>Oops! Try again, I know you can do it!</b>', 'warn');

      // Unlock next after 5 tries (right or wrong)
      if (state.attempts >= 5) {
        nextBtn.disabled = false;
      }
    }
    checkBtn.disabled = true;
    updateHUD();
  }

  function nextRound() {
    if (!nextBtn.disabled) {
      if (state.q < state.total) {
        state.q++;
        startRound();
      } else {
        showSummary();
      }
    }
  }

  function showSummary() {
    setFeedback('');
    nextBtn.disabled = true;
    checkBtn.disabled = true;
    if (finalScoreEl) finalScoreEl.textContent = `You scored ${state.score}/${state.total}.`;
    if (summary) summary.hidden = false;
  }

  function startNewSet() {
    state.q = 1;
    state.score = 0;
    if (summary) summary.hidden = true;
    startRound();
  }

  function resetSelection() {
    if (state.locked) return; // keep final view
    resetSelectionUI();
    setFeedback('Selection cleared. Pick two denominators, then press Check.');
  }

  // -------- Wire up --------
  checkBtn.addEventListener('click', checkAnswer);
  nextBtn.addEventListener('click', nextRound);
  resetBtn.addEventListener('click', resetSelection);
  if (playAgainBtn) playAgainBtn.addEventListener('click', startNewSet);

  // -------- Go --------
  startRound();
})();
